{
  "ownKey": "kotlindoc",
  "childrenPages": {"kotlindoc": {
    "ownKey": "kotlindoc",
    "childrenPages": {
      "jvm": {
        "ownKey": "jvm",
        "ownPages": [{
          "reference": {
            "path": "kotlindoc",
            "baseUrl": "https://copper-leaf.github.io/clog",
            "fileName": "jvm",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/clog/kotlindoc/jvm"
          },
          "description": "",
          "title": "JVM",
          "content": "<h2 id=\"clog\"><a href=\"#clog\" id=\"clog\" class=\"anchor\"><\/a>Clog<\/h2>\n<p>Zero-config Kotlin multiplatform logging utility, strongly inspired by the <a href=\"http://www.slf4j.org/\">SLF4J<\/a> and\n<a href=\"https://github.com/JakeWharton/timber\">Timber<\/a> APIs.<\/p>\n<p><img src=\"https://img.shields.io/github/v/release/copper-leaf/clog\" alt=\"GitHub release (latest by date)\" />\n<img src=\"https://img.shields.io/maven-central/v/io.github.copper-leaf/clog-core\" alt=\"Maven Central\" />\n<img src=\"https://img.shields.io/badge/Kotlin-1.4.32-orange\" alt=\"Kotlin Version\" /><\/p>\n<p>Clog is designed with the following goals in mind:<\/p>\n<ul>\n<li><strong>Zero setup required<\/strong>: just add the dependency and start logging<\/li>\n<li><strong>Support natural logging for each platform<\/strong>: use <code>actual/expect<\/code> declarations to provide natural logging targets for\neach platform, rather than printing everything to stdout<\/li>\n<li><strong>Be a central logger<\/strong>: Unlike many other Kotlin/Multiplatform loggers which simply delegate to SLF4j, Clog is designed\nto be the central logger instead of a wrapper around another logger. Clog <em>is<\/em> an SLF4J implementation, so logs from\nother libraries will be passed through to Clog and can be configured and filtered using Clog's APIs.<\/li>\n<li><strong>Support existing standards for logging<\/strong>: with the API of Timber and semantics compatible with SLF4J, Clog is a\nnatural way to transition your JVM-specific logging into the Kotlin/Multiplatform world<\/li>\n<li><strong>Customization is there if you need it<\/strong>: the Clog singleton can be easily configured with custom classes to apply\nyour own formatting, filtering, and logging targets<\/li>\n<li><strong>Immutable loggers<\/strong>: The ClogProfile and all classes implementing the logger are immutable, for multithreaded\nperformance and safety. The global Clog instance is updated only by swapping out the backing instance, and you're\nfree to bypass the global instance entirely and inject loggers instead.<\/li>\n<\/ul>\n<h3 id=\"supported-platformsfeatures\"><a href=\"#supported-platformsfeatures\" id=\"supported-platformsfeatures\" class=\"anchor\"><\/a>Supported Platforms/Features<\/h3>\n<table class=\"table\">\n<thead>\n<tr><th>Platform<\/th><th>Logging Target<\/th><th>ANSI Colors<\/th><th>Tag Inference<\/th><th>Message Formatting<\/th><th>SLF4J Integration<\/th><th>SLF4J MDC Support<\/th><\/tr>\n<\/thead>\n<tbody>\n<tr><td>JVM<\/td><td>System.out<\/td><td>✅<\/td><td>✅<\/td><td>✅<\/td><td>✅<\/td><td>✅<\/td><\/tr>\n<tr><td>Android<\/td><td>android.util.Log<\/td><td>❌<\/td><td>✅<\/td><td>✅<\/td><td>✅<\/td><td>❌<\/td><\/tr>\n<tr><td>JS<\/td><td>console.log<\/td><td>❌<\/td><td>❌<\/td><td>✅<\/td><td>❌<\/td><td>❌<\/td><\/tr>\n<tr><td>iOS<\/td><td>NSLog<\/td><td>❌<\/td><td>❌<\/td><td>✅<\/td><td>❌<\/td><td>❌<\/td><\/tr>\n<\/tbody>\n<\/table>\n<h3 id=\"installation\"><a href=\"#installation\" id=\"installation\" class=\"anchor\"><\/a>Installation<\/h3>\n<pre><code class=\"language-kotlin\">repositories {\n    mavenCentral()\n}\n\n// for plain JVM or Android projects\ndependencies {\n    implementation(&quot;io.github.copper-leaf:clog-core:4.1.1&quot;)\n}\n\n// for multiplatform projects\nkotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                implementation(&quot;io.github.copper-leaf:clog-core:4.1.1&quot;)\n            }\n        }\n    }\n}\n<\/code><\/pre>\n<h2 id=\"usage\"><a href=\"#usage\" id=\"usage\" class=\"anchor\"><\/a>Usage<\/h2>\n<p>Clog's logging levels generally follow the SLF4J logging levels, and the API follows a similar API as\n<a href=\"https://developer.android.com/reference/android/util/Log\">android.util.log<\/a> or\n<a href=\"https://github.com/JakeWharton/timber\">Timber<\/a>.<\/p>\n<table class=\"table\">\n<thead>\n<tr><th>Clog Level<\/th><th>Clog Method<\/th><th>SLF4J Level<\/th><\/tr>\n<\/thead>\n<tbody>\n<tr><td>Verbose<\/td><td><code>Clog.v()<\/code><\/td><td><code>logger.trace()<\/code><\/td><\/tr>\n<tr><td>Debug<\/td><td><code>Clog.d()<\/code><\/td><td><code>logger.debug()<\/code><\/td><\/tr>\n<tr><td>Info<\/td><td><code>Clog.i()<\/code><\/td><td><code>logger.info()<\/code><\/td><\/tr>\n<tr><td>Default<\/td><td><code>Clog.log()<\/code><\/td><td>N/A<\/td><\/tr>\n<tr><td>Warning<\/td><td><code>Clog.w()<\/code><\/td><td><code>logger.warn()<\/code><\/td><\/tr>\n<tr><td>Error<\/td><td><code>Clog.e()<\/code><\/td><td><code>logger.error()<\/code><\/td><\/tr>\n<tr><td>Fatal<\/td><td><code>Clog.wtf()<\/code><\/td><td>N/A<\/td><\/tr>\n<\/tbody>\n<\/table>\n<p>In general, a log consists of a <em>message<\/em> (which may be formatted with params in SLF4J-style), a <em>tag<\/em>, and a\n<em>log level<\/em>. Below is a description of the API<\/p>\n<h3 id=\"normal-log-messages\"><a href=\"#normal-log-messages\" id=\"normal-log-messages\" class=\"anchor\"><\/a>Normal log messages<\/h3>\n<p>Tag will be inferred on supported platforms, based on the calling class<\/p>\n<pre><code class=\"language-kotlin\">Clog.v(&quot;message&quot;)\nClog.d(&quot;message&quot;)\nClog.i(&quot;message&quot;)\nClog.log(&quot;message&quot;)\nClog.w(&quot;message&quot;)\nClog.e(&quot;message&quot;)\nClog.wtf(&quot;message&quot;)\n<\/code><\/pre>\n<h3 id=\"logs-with-custom-tags\"><a href=\"#logs-with-custom-tags\" id=\"logs-with-custom-tags\" class=\"anchor\"><\/a>Logs with custom tags<\/h3>\n<pre><code class=\"language-kotlin\">Clog.tag(&quot;tag&quot;).v(&quot;message&quot;)\nClog.tag(&quot;tag&quot;).d(&quot;message&quot;)\nClog.tag(&quot;tag&quot;).i(&quot;message&quot;)\nClog.tag(&quot;tag&quot;).w(&quot;message&quot;)\nClog.tag(&quot;tag&quot;).e(&quot;message&quot;)\nClog.tag(&quot;tag&quot;).wtf(&quot;message&quot;)\n<\/code><\/pre>\n<h3 id=\"log-exceptions\"><a href=\"#log-exceptions\" id=\"log-exceptions\" class=\"anchor\"><\/a>Log exceptions<\/h3>\n<pre><code class=\"language-kotlin\">val e = RuntimeException()\nClog.v(e)\nClog.d(e)\nClog.i(e)\nClog.log(e)\nClog.w(e)\nClog.e(e)\nClog.wtf(e)\n<\/code><\/pre>\n<h3 id=\"message-formatting\"><a href=\"#message-formatting\" id=\"message-formatting\" class=\"anchor\"><\/a>Message Formatting<\/h3>\n<p>SLF4j-style formatting is supported, replacing <code>{}<\/code> with params passed to the logging call. This is supported on all\nplatforms and all log levels.<\/p>\n<pre><code class=\"language-kotlin\">val foo = &quot;bar&quot;\nClog.i(&quot;message {}&quot;, foo) // logs 'message bar'\n<\/code><\/pre>\n<h3 id=\"priority-filter\"><a href=\"#priority-filter\" id=\"priority-filter\" class=\"anchor\"><\/a>Priority Filter<\/h3>\n<p>Messages and exceptions can be filtered out by priority.<\/p>\n<pre><code class=\"language-kotlin\">Clog.setMinPriority(Clog.Priority.ERROR)\n<\/code><\/pre>\n<h3 id=\"tag-whitelistingblacklisting\"><a href=\"#tag-whitelistingblacklisting\" id=\"tag-whitelistingblacklisting\" class=\"anchor\"><\/a>Tag whitelisting/blacklisting<\/h3>\n<p>Messages can be filtered out by tags.<\/p>\n<pre><code class=\"language-kotlin\">Clog.addTagToWhitelist(&quot;tag1&quot;)\nClog.addTagToBlacklist(&quot;tag2&quot;)\n<\/code><\/pre>\n<h2 id=\"lambda-dsl\"><a href=\"#lambda-dsl\" id=\"lambda-dsl\" class=\"anchor\"><\/a>Lambda DSL<\/h2>\n<p>Using the Clog DSL, simple strings can be logged lazily. The lambda is only evaluated if the logging level and tag is\nenabled. By default, messages logged with the lambda DSL are not formatted, but it can be re-enabled by using <code>format()<\/code>\ninside the lambda.<\/p>\n<h3 id=\"normal-log-messages-1\"><a href=\"#normal-log-messages-1\" id=\"normal-log-messages-1\" class=\"anchor\"><\/a>Normal log messages<\/h3>\n<pre><code class=\"language-kotlin\">import clog.dsl.*\n\nv   { &quot;message&quot; }\nd   { &quot;message&quot; }\ni   { &quot;message&quot; }\nw   { &quot;message&quot; }\ne   { &quot;message&quot; }\nwtf { &quot;message&quot; }\n<\/code><\/pre>\n<h3 id=\"logs-with-custom-tags-1\"><a href=\"#logs-with-custom-tags-1\" id=\"logs-with-custom-tags-1\" class=\"anchor\"><\/a>Logs with custom tags<\/h3>\n<pre><code class=\"language-kotlin\">import clog.dsl.*\n\nv(&quot;tag&quot;)   { &quot;message&quot; }\nd(&quot;tag&quot;)   { &quot;message&quot; }\ni(&quot;tag&quot;)   { &quot;message&quot; }\nw(&quot;tag&quot;)   { &quot;message&quot; }\ne(&quot;tag&quot;)   { &quot;message&quot; }\nwtf(&quot;tag&quot;) { &quot;message&quot; }\n<\/code><\/pre>\n<h3 id=\"message-formatting-1\"><a href=\"#message-formatting-1\" id=\"message-formatting-1\" class=\"anchor\"><\/a>Message formatting<\/h3>\n<pre><code class=\"language-kotlin\">import clog.dsl.*\n\nval foo = &quot;bar&quot; \nv   { format(&quot;message {}&quot;, foo) } // logs 'message bar'\nd   { format(&quot;message {}&quot;, foo) } // logs 'message bar'\ni   { format(&quot;message {}&quot;, foo) } // logs 'message bar'\nw   { format(&quot;message {}&quot;, foo) } // logs 'message bar'\ne   { format(&quot;message {}&quot;, foo) } // logs 'message bar'\nwtf { format(&quot;message {}&quot;, foo) } // logs 'message bar'\n<\/code><\/pre>\n<h2 id=\"slf4j\"><a href=\"#slf4j\" id=\"slf4j\" class=\"anchor\"><\/a>SLF4J<\/h2>\n<p>On plain JVM and Android platforms, Clog is set up as an SLF4J binding; that is, SLF4J will pass log messages through to\nClog. Other libraries and frameworks logging to SLF4J will be formatted as normal Clog logs for uniform log output, and\nso Clog can be used as a simple SLF4J binding when you don't want to configure Logback. Additionally, SLF Mapped\nDiagnostic Context (MDC) is supported, and context data can be added to log messages with the standard format of\n<code>%X{mdcKey}<\/code>.<\/p>\n<pre><code class=\"language-kotlin\">val slf4j: Logger = LoggerFactory.getLogger(JvmClogSlf4jTest::class.java)\n\nMDC.put(&quot;akey&quot;, &quot;avalue&quot;)\nslf4j.trace(&quot;message %X{akey}&quot;) // logs 'message avalue' to the Clog logger\n<\/code><\/pre>\n<h2 id=\"more-customization\"><a href=\"#more-customization\" id=\"more-customization\" class=\"anchor\"><\/a>More Customization<\/h2>\n<p>Clog is designed to work out-of-the-box with absolutely zero config required to start logging with it. However, you can\ncustomize all components of Clog to your needs. Clog is comprised of several components wrapped in a <code>ClogProfile<\/code>,\nwhich is the global instance of <code>Clog.getInstance()<\/code>. You can customize your Clog by creating a new Profile with your\ncustom components:<\/p>\n<pre><code class=\"language-kotlin\">val newProfile = ClogProfile(...)\nClog.setProfile(newProfile)\n<\/code><\/pre>\n<p>You can also use the <code>Clog.updateProfile<\/code> helper to create a profile based on the current global instance:<\/p>\n<pre><code class=\"language-kotlin\">Clog.updateProfile { it.copy(logger = newLogger) }\n<\/code><\/pre>\n<p>The table below describes the classes that can be customized in the <code>ClogProfile<\/code>, along with their default\nimplementation for each supported platform:<\/p>\n<table class=\"table\">\n<thead>\n<tr><th>Interface<\/th><th>Description<\/th><th>JVM<\/th><th>Android<\/th><th>JS<\/th><th>iOS<\/th><\/tr>\n<\/thead>\n<tbody>\n<tr><td><code>ClogTagProvider<\/code><\/td><td>Infers a tag if one is not provided to the logging call<\/td><td><code>DefaultTagProvider()<\/code><\/td><td><code>DefaultTagProvider()<\/code><\/td><td><code>DefaultTagProvider()<\/code><\/td><td><code>DefaultTagProvider()<\/code><\/td><\/tr>\n<tr><td><code>ClogMessageFormatter<\/code><\/td><td>Formats a message string to pass to the <code>ClogLogger<\/code><\/td><td><code>Slf4jMessageFormatter(DefaultMessageFormatter())<\/code><\/td><td><code>DefaultMessageFormatter()<\/code><\/td><td><code>DefaultMessageFormatter()<\/code><\/td><td><code>DefaultMessageFormatter()<\/code><\/td><\/tr>\n<tr><td><code>ClogFilter<\/code><\/td><td>Determines whether to format and log a message<\/td><td><code>DefaultFilter()<\/code><\/td><td><code>DefaultFilter()<\/code><\/td><td><code>DefaultFilter()<\/code><\/td><td><code>DefaultFilter()<\/code><\/td><\/tr>\n<tr><td><code>ClogLogger<\/code><\/td><td>Prints a formatted log to a lower-level platform-specific logger or console<\/td><td><code>DefaultLogger()<\/code><\/td><td><code>AndroidLogger()<\/code><\/td><td><code>JsConsoleLogger()<\/code><\/td><td><code>NsLogger()<\/code><\/td><\/tr>\n<\/tbody>\n<\/table>\n<h2 id=\"recipes\"><a href=\"#recipes\" id=\"recipes\" class=\"anchor\"><\/a>Recipes<\/h2>\n<h3 id=\"turn-off-logging-in-production\"><a href=\"#turn-off-logging-in-production\" id=\"turn-off-logging-in-production\" class=\"anchor\"><\/a>Turn off logging in production<\/h3>\n<pre><code class=\"language-kotlin\">val isDebug = ...\nClog.configureLoggingInProduction(isDebug)\n<\/code><\/pre>\n<h3 id=\"use-a-custom-logger\"><a href=\"#use-a-custom-logger\" id=\"use-a-custom-logger\" class=\"anchor\"><\/a>Use a custom logger<\/h3>\n<p>Replaces the current logging target with a custom one.<\/p>\n<pre><code class=\"language-kotlin\">val customLogger = object : ClogLogger {\n    override fun log(priority: Clog.Priority, tag: String?, message: String) {\n        ...\n    }\n    override fun logException(priority: Clog.Priority, tag: String?, throwable: Throwable) {\n        ...\n    }\n}\nClog.updateProfile { it.copy(logger = customLogger) }\n<\/code><\/pre>\n<h3 id=\"using-multiple-logging-targets\"><a href=\"#using-multiple-logging-targets\" id=\"using-multiple-logging-targets\" class=\"anchor\"><\/a>Using multiple logging targets<\/h3>\n<p>Add an additional logger to the current instance. Calling <code>addLogger<\/code> multiple times will continue adding loggers, and\nmessages will be delegated to all loggers.<\/p>\n<pre><code class=\"language-kotlin\">val customLogger = object : ClogLogger {\n    override fun log(priority: Clog.Priority, tag: String?, message: String) {\n        ...\n    }\n    override fun logException(priority: Clog.Priority, tag: String?, throwable: Throwable) {\n        ...\n    }\n}\nClog.addLogger(customLogger)\n<\/code><\/pre>\n<h3 id=\"using-clog-with-dependency-injection\"><a href=\"#using-clog-with-dependency-injection\" id=\"using-clog-with-dependency-injection\" class=\"anchor\"><\/a>Using Clog with dependency injection<\/h3>\n<pre><code class=\"language-kotlin\">// Given some classes that depend on a logger\nclass Controller(val logger: ClogProfile) \n\n// just declare a ClogProfile singleton with any configurations you need \nval module = module { \n  single { ClogProfile() } \n  single { Controller(get()) } \n} \n<\/code><\/pre>\n"
        }]
      },
      "common": {
        "ownKey": "common",
        "ownPages": [{
          "reference": {
            "path": "kotlindoc",
            "baseUrl": "https://copper-leaf.github.io/clog",
            "fileName": "common",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/clog/kotlindoc/common"
          },
          "description": "",
          "title": "Common",
          "content": "<h2 id=\"clog\"><a href=\"#clog\" id=\"clog\" class=\"anchor\"><\/a>Clog<\/h2>\n<p>Zero-config Kotlin multiplatform logging utility, strongly inspired by the <a href=\"http://www.slf4j.org/\">SLF4J<\/a> and\n<a href=\"https://github.com/JakeWharton/timber\">Timber<\/a> APIs.<\/p>\n<p><img src=\"https://img.shields.io/github/v/release/copper-leaf/clog\" alt=\"GitHub release (latest by date)\" />\n<img src=\"https://img.shields.io/maven-central/v/io.github.copper-leaf/clog-core\" alt=\"Maven Central\" />\n<img src=\"https://img.shields.io/badge/Kotlin-1.4.32-orange\" alt=\"Kotlin Version\" /><\/p>\n<p>Clog is designed with the following goals in mind:<\/p>\n<ul>\n<li><strong>Zero setup required<\/strong>: just add the dependency and start logging<\/li>\n<li><strong>Support natural logging for each platform<\/strong>: use <code>actual/expect<\/code> declarations to provide natural logging targets for\neach platform, rather than printing everything to stdout<\/li>\n<li><strong>Be a central logger<\/strong>: Unlike many other Kotlin/Multiplatform loggers which simply delegate to SLF4j, Clog is designed\nto be the central logger instead of a wrapper around another logger. Clog <em>is<\/em> an SLF4J implementation, so logs from\nother libraries will be passed through to Clog and can be configured and filtered using Clog's APIs.<\/li>\n<li><strong>Support existing standards for logging<\/strong>: with the API of Timber and semantics compatible with SLF4J, Clog is a\nnatural way to transition your JVM-specific logging into the Kotlin/Multiplatform world<\/li>\n<li><strong>Customization is there if you need it<\/strong>: the Clog singleton can be easily configured with custom classes to apply\nyour own formatting, filtering, and logging targets<\/li>\n<li><strong>Immutable loggers<\/strong>: The ClogProfile and all classes implementing the logger are immutable, for multithreaded\nperformance and safety. The global Clog instance is updated only by swapping out the backing instance, and you're\nfree to bypass the global instance entirely and inject loggers instead.<\/li>\n<\/ul>\n<h3 id=\"supported-platformsfeatures\"><a href=\"#supported-platformsfeatures\" id=\"supported-platformsfeatures\" class=\"anchor\"><\/a>Supported Platforms/Features<\/h3>\n<table class=\"table\">\n<thead>\n<tr><th>Platform<\/th><th>Logging Target<\/th><th>ANSI Colors<\/th><th>Tag Inference<\/th><th>Message Formatting<\/th><th>SLF4J Integration<\/th><th>SLF4J MDC Support<\/th><\/tr>\n<\/thead>\n<tbody>\n<tr><td>JVM<\/td><td>System.out<\/td><td>✅<\/td><td>✅<\/td><td>✅<\/td><td>✅<\/td><td>✅<\/td><\/tr>\n<tr><td>Android<\/td><td>android.util.Log<\/td><td>❌<\/td><td>✅<\/td><td>✅<\/td><td>✅<\/td><td>❌<\/td><\/tr>\n<tr><td>JS<\/td><td>console.log<\/td><td>❌<\/td><td>❌<\/td><td>✅<\/td><td>❌<\/td><td>❌<\/td><\/tr>\n<tr><td>iOS<\/td><td>NSLog<\/td><td>❌<\/td><td>❌<\/td><td>✅<\/td><td>❌<\/td><td>❌<\/td><\/tr>\n<\/tbody>\n<\/table>\n<h3 id=\"installation\"><a href=\"#installation\" id=\"installation\" class=\"anchor\"><\/a>Installation<\/h3>\n<pre><code class=\"language-kotlin\">repositories {\n    mavenCentral()\n}\n\n// for plain JVM or Android projects\ndependencies {\n    implementation(&quot;io.github.copper-leaf:clog-core:4.1.1&quot;)\n}\n\n// for multiplatform projects\nkotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                implementation(&quot;io.github.copper-leaf:clog-core:4.1.1&quot;)\n            }\n        }\n    }\n}\n<\/code><\/pre>\n<h2 id=\"usage\"><a href=\"#usage\" id=\"usage\" class=\"anchor\"><\/a>Usage<\/h2>\n<p>Clog's logging levels generally follow the SLF4J logging levels, and the API follows a similar API as\n<a href=\"https://developer.android.com/reference/android/util/Log\">android.util.log<\/a> or\n<a href=\"https://github.com/JakeWharton/timber\">Timber<\/a>.<\/p>\n<table class=\"table\">\n<thead>\n<tr><th>Clog Level<\/th><th>Clog Method<\/th><th>SLF4J Level<\/th><\/tr>\n<\/thead>\n<tbody>\n<tr><td>Verbose<\/td><td><code>Clog.v()<\/code><\/td><td><code>logger.trace()<\/code><\/td><\/tr>\n<tr><td>Debug<\/td><td><code>Clog.d()<\/code><\/td><td><code>logger.debug()<\/code><\/td><\/tr>\n<tr><td>Info<\/td><td><code>Clog.i()<\/code><\/td><td><code>logger.info()<\/code><\/td><\/tr>\n<tr><td>Default<\/td><td><code>Clog.log()<\/code><\/td><td>N/A<\/td><\/tr>\n<tr><td>Warning<\/td><td><code>Clog.w()<\/code><\/td><td><code>logger.warn()<\/code><\/td><\/tr>\n<tr><td>Error<\/td><td><code>Clog.e()<\/code><\/td><td><code>logger.error()<\/code><\/td><\/tr>\n<tr><td>Fatal<\/td><td><code>Clog.wtf()<\/code><\/td><td>N/A<\/td><\/tr>\n<\/tbody>\n<\/table>\n<p>In general, a log consists of a <em>message<\/em> (which may be formatted with params in SLF4J-style), a <em>tag<\/em>, and a\n<em>log level<\/em>. Below is a description of the API<\/p>\n<h3 id=\"normal-log-messages\"><a href=\"#normal-log-messages\" id=\"normal-log-messages\" class=\"anchor\"><\/a>Normal log messages<\/h3>\n<p>Tag will be inferred on supported platforms, based on the calling class<\/p>\n<pre><code class=\"language-kotlin\">Clog.v(&quot;message&quot;)\nClog.d(&quot;message&quot;)\nClog.i(&quot;message&quot;)\nClog.log(&quot;message&quot;)\nClog.w(&quot;message&quot;)\nClog.e(&quot;message&quot;)\nClog.wtf(&quot;message&quot;)\n<\/code><\/pre>\n<h3 id=\"logs-with-custom-tags\"><a href=\"#logs-with-custom-tags\" id=\"logs-with-custom-tags\" class=\"anchor\"><\/a>Logs with custom tags<\/h3>\n<pre><code class=\"language-kotlin\">Clog.tag(&quot;tag&quot;).v(&quot;message&quot;)\nClog.tag(&quot;tag&quot;).d(&quot;message&quot;)\nClog.tag(&quot;tag&quot;).i(&quot;message&quot;)\nClog.tag(&quot;tag&quot;).w(&quot;message&quot;)\nClog.tag(&quot;tag&quot;).e(&quot;message&quot;)\nClog.tag(&quot;tag&quot;).wtf(&quot;message&quot;)\n<\/code><\/pre>\n<h3 id=\"log-exceptions\"><a href=\"#log-exceptions\" id=\"log-exceptions\" class=\"anchor\"><\/a>Log exceptions<\/h3>\n<pre><code class=\"language-kotlin\">val e = RuntimeException()\nClog.v(e)\nClog.d(e)\nClog.i(e)\nClog.log(e)\nClog.w(e)\nClog.e(e)\nClog.wtf(e)\n<\/code><\/pre>\n<h3 id=\"message-formatting\"><a href=\"#message-formatting\" id=\"message-formatting\" class=\"anchor\"><\/a>Message Formatting<\/h3>\n<p>SLF4j-style formatting is supported, replacing <code>{}<\/code> with params passed to the logging call. This is supported on all\nplatforms and all log levels.<\/p>\n<pre><code class=\"language-kotlin\">val foo = &quot;bar&quot;\nClog.i(&quot;message {}&quot;, foo) // logs 'message bar'\n<\/code><\/pre>\n<h3 id=\"priority-filter\"><a href=\"#priority-filter\" id=\"priority-filter\" class=\"anchor\"><\/a>Priority Filter<\/h3>\n<p>Messages and exceptions can be filtered out by priority.<\/p>\n<pre><code class=\"language-kotlin\">Clog.setMinPriority(Clog.Priority.ERROR)\n<\/code><\/pre>\n<h3 id=\"tag-whitelistingblacklisting\"><a href=\"#tag-whitelistingblacklisting\" id=\"tag-whitelistingblacklisting\" class=\"anchor\"><\/a>Tag whitelisting/blacklisting<\/h3>\n<p>Messages can be filtered out by tags.<\/p>\n<pre><code class=\"language-kotlin\">Clog.addTagToWhitelist(&quot;tag1&quot;)\nClog.addTagToBlacklist(&quot;tag2&quot;)\n<\/code><\/pre>\n<h2 id=\"lambda-dsl\"><a href=\"#lambda-dsl\" id=\"lambda-dsl\" class=\"anchor\"><\/a>Lambda DSL<\/h2>\n<p>Using the Clog DSL, simple strings can be logged lazily. The lambda is only evaluated if the logging level and tag is\nenabled. By default, messages logged with the lambda DSL are not formatted, but it can be re-enabled by using <code>format()<\/code>\ninside the lambda.<\/p>\n<h3 id=\"normal-log-messages-1\"><a href=\"#normal-log-messages-1\" id=\"normal-log-messages-1\" class=\"anchor\"><\/a>Normal log messages<\/h3>\n<pre><code class=\"language-kotlin\">import clog.dsl.*\n\nv   { &quot;message&quot; }\nd   { &quot;message&quot; }\ni   { &quot;message&quot; }\nw   { &quot;message&quot; }\ne   { &quot;message&quot; }\nwtf { &quot;message&quot; }\n<\/code><\/pre>\n<h3 id=\"logs-with-custom-tags-1\"><a href=\"#logs-with-custom-tags-1\" id=\"logs-with-custom-tags-1\" class=\"anchor\"><\/a>Logs with custom tags<\/h3>\n<pre><code class=\"language-kotlin\">import clog.dsl.*\n\nv(&quot;tag&quot;)   { &quot;message&quot; }\nd(&quot;tag&quot;)   { &quot;message&quot; }\ni(&quot;tag&quot;)   { &quot;message&quot; }\nw(&quot;tag&quot;)   { &quot;message&quot; }\ne(&quot;tag&quot;)   { &quot;message&quot; }\nwtf(&quot;tag&quot;) { &quot;message&quot; }\n<\/code><\/pre>\n<h3 id=\"message-formatting-1\"><a href=\"#message-formatting-1\" id=\"message-formatting-1\" class=\"anchor\"><\/a>Message formatting<\/h3>\n<pre><code class=\"language-kotlin\">import clog.dsl.*\n\nval foo = &quot;bar&quot; \nv   { format(&quot;message {}&quot;, foo) } // logs 'message bar'\nd   { format(&quot;message {}&quot;, foo) } // logs 'message bar'\ni   { format(&quot;message {}&quot;, foo) } // logs 'message bar'\nw   { format(&quot;message {}&quot;, foo) } // logs 'message bar'\ne   { format(&quot;message {}&quot;, foo) } // logs 'message bar'\nwtf { format(&quot;message {}&quot;, foo) } // logs 'message bar'\n<\/code><\/pre>\n<h2 id=\"slf4j\"><a href=\"#slf4j\" id=\"slf4j\" class=\"anchor\"><\/a>SLF4J<\/h2>\n<p>On plain JVM and Android platforms, Clog is set up as an SLF4J binding; that is, SLF4J will pass log messages through to\nClog. Other libraries and frameworks logging to SLF4J will be formatted as normal Clog logs for uniform log output, and\nso Clog can be used as a simple SLF4J binding when you don't want to configure Logback. Additionally, SLF Mapped\nDiagnostic Context (MDC) is supported, and context data can be added to log messages with the standard format of\n<code>%X{mdcKey}<\/code>.<\/p>\n<pre><code class=\"language-kotlin\">val slf4j: Logger = LoggerFactory.getLogger(JvmClogSlf4jTest::class.java)\n\nMDC.put(&quot;akey&quot;, &quot;avalue&quot;)\nslf4j.trace(&quot;message %X{akey}&quot;) // logs 'message avalue' to the Clog logger\n<\/code><\/pre>\n<h2 id=\"more-customization\"><a href=\"#more-customization\" id=\"more-customization\" class=\"anchor\"><\/a>More Customization<\/h2>\n<p>Clog is designed to work out-of-the-box with absolutely zero config required to start logging with it. However, you can\ncustomize all components of Clog to your needs. Clog is comprised of several components wrapped in a <code>ClogProfile<\/code>,\nwhich is the global instance of <code>Clog.getInstance()<\/code>. You can customize your Clog by creating a new Profile with your\ncustom components:<\/p>\n<pre><code class=\"language-kotlin\">val newProfile = ClogProfile(...)\nClog.setProfile(newProfile)\n<\/code><\/pre>\n<p>You can also use the <code>Clog.updateProfile<\/code> helper to create a profile based on the current global instance:<\/p>\n<pre><code class=\"language-kotlin\">Clog.updateProfile { it.copy(logger = newLogger) }\n<\/code><\/pre>\n<p>The table below describes the classes that can be customized in the <code>ClogProfile<\/code>, along with their default\nimplementation for each supported platform:<\/p>\n<table class=\"table\">\n<thead>\n<tr><th>Interface<\/th><th>Description<\/th><th>JVM<\/th><th>Android<\/th><th>JS<\/th><th>iOS<\/th><\/tr>\n<\/thead>\n<tbody>\n<tr><td><code>ClogTagProvider<\/code><\/td><td>Infers a tag if one is not provided to the logging call<\/td><td><code>DefaultTagProvider()<\/code><\/td><td><code>DefaultTagProvider()<\/code><\/td><td><code>DefaultTagProvider()<\/code><\/td><td><code>DefaultTagProvider()<\/code><\/td><\/tr>\n<tr><td><code>ClogMessageFormatter<\/code><\/td><td>Formats a message string to pass to the <code>ClogLogger<\/code><\/td><td><code>Slf4jMessageFormatter(DefaultMessageFormatter())<\/code><\/td><td><code>DefaultMessageFormatter()<\/code><\/td><td><code>DefaultMessageFormatter()<\/code><\/td><td><code>DefaultMessageFormatter()<\/code><\/td><\/tr>\n<tr><td><code>ClogFilter<\/code><\/td><td>Determines whether to format and log a message<\/td><td><code>DefaultFilter()<\/code><\/td><td><code>DefaultFilter()<\/code><\/td><td><code>DefaultFilter()<\/code><\/td><td><code>DefaultFilter()<\/code><\/td><\/tr>\n<tr><td><code>ClogLogger<\/code><\/td><td>Prints a formatted log to a lower-level platform-specific logger or console<\/td><td><code>DefaultLogger()<\/code><\/td><td><code>AndroidLogger()<\/code><\/td><td><code>JsConsoleLogger()<\/code><\/td><td><code>NsLogger()<\/code><\/td><\/tr>\n<\/tbody>\n<\/table>\n<h2 id=\"recipes\"><a href=\"#recipes\" id=\"recipes\" class=\"anchor\"><\/a>Recipes<\/h2>\n<h3 id=\"turn-off-logging-in-production\"><a href=\"#turn-off-logging-in-production\" id=\"turn-off-logging-in-production\" class=\"anchor\"><\/a>Turn off logging in production<\/h3>\n<pre><code class=\"language-kotlin\">val isDebug = ...\nClog.configureLoggingInProduction(isDebug)\n<\/code><\/pre>\n<h3 id=\"use-a-custom-logger\"><a href=\"#use-a-custom-logger\" id=\"use-a-custom-logger\" class=\"anchor\"><\/a>Use a custom logger<\/h3>\n<p>Replaces the current logging target with a custom one.<\/p>\n<pre><code class=\"language-kotlin\">val customLogger = object : ClogLogger {\n    override fun log(priority: Clog.Priority, tag: String?, message: String) {\n        ...\n    }\n    override fun logException(priority: Clog.Priority, tag: String?, throwable: Throwable) {\n        ...\n    }\n}\nClog.updateProfile { it.copy(logger = customLogger) }\n<\/code><\/pre>\n<h3 id=\"using-multiple-logging-targets\"><a href=\"#using-multiple-logging-targets\" id=\"using-multiple-logging-targets\" class=\"anchor\"><\/a>Using multiple logging targets<\/h3>\n<p>Add an additional logger to the current instance. Calling <code>addLogger<\/code> multiple times will continue adding loggers, and\nmessages will be delegated to all loggers.<\/p>\n<pre><code class=\"language-kotlin\">val customLogger = object : ClogLogger {\n    override fun log(priority: Clog.Priority, tag: String?, message: String) {\n        ...\n    }\n    override fun logException(priority: Clog.Priority, tag: String?, throwable: Throwable) {\n        ...\n    }\n}\nClog.addLogger(customLogger)\n<\/code><\/pre>\n<h3 id=\"using-clog-with-dependency-injection\"><a href=\"#using-clog-with-dependency-injection\" id=\"using-clog-with-dependency-injection\" class=\"anchor\"><\/a>Using Clog with dependency injection<\/h3>\n<pre><code class=\"language-kotlin\">// Given some classes that depend on a logger\nclass Controller(val logger: ClogProfile) \n\n// just declare a ClogProfile singleton with any configurations you need \nval module = module { \n  single { ClogProfile() } \n  single { Controller(get()) } \n} \n<\/code><\/pre>\n"
        }]
      },
      "android": {
        "ownKey": "android",
        "ownPages": [{
          "reference": {
            "path": "kotlindoc",
            "baseUrl": "https://copper-leaf.github.io/clog",
            "fileName": "android",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/clog/kotlindoc/android"
          },
          "description": "",
          "title": "Android",
          "content": "<h2 id=\"clog\"><a href=\"#clog\" id=\"clog\" class=\"anchor\"><\/a>Clog<\/h2>\n<p>Zero-config Kotlin multiplatform logging utility, strongly inspired by the <a href=\"http://www.slf4j.org/\">SLF4J<\/a> and\n<a href=\"https://github.com/JakeWharton/timber\">Timber<\/a> APIs.<\/p>\n<p><img src=\"https://img.shields.io/github/v/release/copper-leaf/clog\" alt=\"GitHub release (latest by date)\" />\n<img src=\"https://img.shields.io/maven-central/v/io.github.copper-leaf/clog-core\" alt=\"Maven Central\" />\n<img src=\"https://img.shields.io/badge/Kotlin-1.4.32-orange\" alt=\"Kotlin Version\" /><\/p>\n<p>Clog is designed with the following goals in mind:<\/p>\n<ul>\n<li><strong>Zero setup required<\/strong>: just add the dependency and start logging<\/li>\n<li><strong>Support natural logging for each platform<\/strong>: use <code>actual/expect<\/code> declarations to provide natural logging targets for\neach platform, rather than printing everything to stdout<\/li>\n<li><strong>Be a central logger<\/strong>: Unlike many other Kotlin/Multiplatform loggers which simply delegate to SLF4j, Clog is designed\nto be the central logger instead of a wrapper around another logger. Clog <em>is<\/em> an SLF4J implementation, so logs from\nother libraries will be passed through to Clog and can be configured and filtered using Clog's APIs.<\/li>\n<li><strong>Support existing standards for logging<\/strong>: with the API of Timber and semantics compatible with SLF4J, Clog is a\nnatural way to transition your JVM-specific logging into the Kotlin/Multiplatform world<\/li>\n<li><strong>Customization is there if you need it<\/strong>: the Clog singleton can be easily configured with custom classes to apply\nyour own formatting, filtering, and logging targets<\/li>\n<li><strong>Immutable loggers<\/strong>: The ClogProfile and all classes implementing the logger are immutable, for multithreaded\nperformance and safety. The global Clog instance is updated only by swapping out the backing instance, and you're\nfree to bypass the global instance entirely and inject loggers instead.<\/li>\n<\/ul>\n<h3 id=\"supported-platformsfeatures\"><a href=\"#supported-platformsfeatures\" id=\"supported-platformsfeatures\" class=\"anchor\"><\/a>Supported Platforms/Features<\/h3>\n<table class=\"table\">\n<thead>\n<tr><th>Platform<\/th><th>Logging Target<\/th><th>ANSI Colors<\/th><th>Tag Inference<\/th><th>Message Formatting<\/th><th>SLF4J Integration<\/th><th>SLF4J MDC Support<\/th><\/tr>\n<\/thead>\n<tbody>\n<tr><td>JVM<\/td><td>System.out<\/td><td>✅<\/td><td>✅<\/td><td>✅<\/td><td>✅<\/td><td>✅<\/td><\/tr>\n<tr><td>Android<\/td><td>android.util.Log<\/td><td>❌<\/td><td>✅<\/td><td>✅<\/td><td>✅<\/td><td>❌<\/td><\/tr>\n<tr><td>JS<\/td><td>console.log<\/td><td>❌<\/td><td>❌<\/td><td>✅<\/td><td>❌<\/td><td>❌<\/td><\/tr>\n<tr><td>iOS<\/td><td>NSLog<\/td><td>❌<\/td><td>❌<\/td><td>✅<\/td><td>❌<\/td><td>❌<\/td><\/tr>\n<\/tbody>\n<\/table>\n<h3 id=\"installation\"><a href=\"#installation\" id=\"installation\" class=\"anchor\"><\/a>Installation<\/h3>\n<pre><code class=\"language-kotlin\">repositories {\n    mavenCentral()\n}\n\n// for plain JVM or Android projects\ndependencies {\n    implementation(&quot;io.github.copper-leaf:clog-core:4.1.1&quot;)\n}\n\n// for multiplatform projects\nkotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                implementation(&quot;io.github.copper-leaf:clog-core:4.1.1&quot;)\n            }\n        }\n    }\n}\n<\/code><\/pre>\n<h2 id=\"usage\"><a href=\"#usage\" id=\"usage\" class=\"anchor\"><\/a>Usage<\/h2>\n<p>Clog's logging levels generally follow the SLF4J logging levels, and the API follows a similar API as\n<a href=\"https://developer.android.com/reference/android/util/Log\">android.util.log<\/a> or\n<a href=\"https://github.com/JakeWharton/timber\">Timber<\/a>.<\/p>\n<table class=\"table\">\n<thead>\n<tr><th>Clog Level<\/th><th>Clog Method<\/th><th>SLF4J Level<\/th><\/tr>\n<\/thead>\n<tbody>\n<tr><td>Verbose<\/td><td><code>Clog.v()<\/code><\/td><td><code>logger.trace()<\/code><\/td><\/tr>\n<tr><td>Debug<\/td><td><code>Clog.d()<\/code><\/td><td><code>logger.debug()<\/code><\/td><\/tr>\n<tr><td>Info<\/td><td><code>Clog.i()<\/code><\/td><td><code>logger.info()<\/code><\/td><\/tr>\n<tr><td>Default<\/td><td><code>Clog.log()<\/code><\/td><td>N/A<\/td><\/tr>\n<tr><td>Warning<\/td><td><code>Clog.w()<\/code><\/td><td><code>logger.warn()<\/code><\/td><\/tr>\n<tr><td>Error<\/td><td><code>Clog.e()<\/code><\/td><td><code>logger.error()<\/code><\/td><\/tr>\n<tr><td>Fatal<\/td><td><code>Clog.wtf()<\/code><\/td><td>N/A<\/td><\/tr>\n<\/tbody>\n<\/table>\n<p>In general, a log consists of a <em>message<\/em> (which may be formatted with params in SLF4J-style), a <em>tag<\/em>, and a\n<em>log level<\/em>. Below is a description of the API<\/p>\n<h3 id=\"normal-log-messages\"><a href=\"#normal-log-messages\" id=\"normal-log-messages\" class=\"anchor\"><\/a>Normal log messages<\/h3>\n<p>Tag will be inferred on supported platforms, based on the calling class<\/p>\n<pre><code class=\"language-kotlin\">Clog.v(&quot;message&quot;)\nClog.d(&quot;message&quot;)\nClog.i(&quot;message&quot;)\nClog.log(&quot;message&quot;)\nClog.w(&quot;message&quot;)\nClog.e(&quot;message&quot;)\nClog.wtf(&quot;message&quot;)\n<\/code><\/pre>\n<h3 id=\"logs-with-custom-tags\"><a href=\"#logs-with-custom-tags\" id=\"logs-with-custom-tags\" class=\"anchor\"><\/a>Logs with custom tags<\/h3>\n<pre><code class=\"language-kotlin\">Clog.tag(&quot;tag&quot;).v(&quot;message&quot;)\nClog.tag(&quot;tag&quot;).d(&quot;message&quot;)\nClog.tag(&quot;tag&quot;).i(&quot;message&quot;)\nClog.tag(&quot;tag&quot;).w(&quot;message&quot;)\nClog.tag(&quot;tag&quot;).e(&quot;message&quot;)\nClog.tag(&quot;tag&quot;).wtf(&quot;message&quot;)\n<\/code><\/pre>\n<h3 id=\"log-exceptions\"><a href=\"#log-exceptions\" id=\"log-exceptions\" class=\"anchor\"><\/a>Log exceptions<\/h3>\n<pre><code class=\"language-kotlin\">val e = RuntimeException()\nClog.v(e)\nClog.d(e)\nClog.i(e)\nClog.log(e)\nClog.w(e)\nClog.e(e)\nClog.wtf(e)\n<\/code><\/pre>\n<h3 id=\"message-formatting\"><a href=\"#message-formatting\" id=\"message-formatting\" class=\"anchor\"><\/a>Message Formatting<\/h3>\n<p>SLF4j-style formatting is supported, replacing <code>{}<\/code> with params passed to the logging call. This is supported on all\nplatforms and all log levels.<\/p>\n<pre><code class=\"language-kotlin\">val foo = &quot;bar&quot;\nClog.i(&quot;message {}&quot;, foo) // logs 'message bar'\n<\/code><\/pre>\n<h3 id=\"priority-filter\"><a href=\"#priority-filter\" id=\"priority-filter\" class=\"anchor\"><\/a>Priority Filter<\/h3>\n<p>Messages and exceptions can be filtered out by priority.<\/p>\n<pre><code class=\"language-kotlin\">Clog.setMinPriority(Clog.Priority.ERROR)\n<\/code><\/pre>\n<h3 id=\"tag-whitelistingblacklisting\"><a href=\"#tag-whitelistingblacklisting\" id=\"tag-whitelistingblacklisting\" class=\"anchor\"><\/a>Tag whitelisting/blacklisting<\/h3>\n<p>Messages can be filtered out by tags.<\/p>\n<pre><code class=\"language-kotlin\">Clog.addTagToWhitelist(&quot;tag1&quot;)\nClog.addTagToBlacklist(&quot;tag2&quot;)\n<\/code><\/pre>\n<h2 id=\"lambda-dsl\"><a href=\"#lambda-dsl\" id=\"lambda-dsl\" class=\"anchor\"><\/a>Lambda DSL<\/h2>\n<p>Using the Clog DSL, simple strings can be logged lazily. The lambda is only evaluated if the logging level and tag is\nenabled. By default, messages logged with the lambda DSL are not formatted, but it can be re-enabled by using <code>format()<\/code>\ninside the lambda.<\/p>\n<h3 id=\"normal-log-messages-1\"><a href=\"#normal-log-messages-1\" id=\"normal-log-messages-1\" class=\"anchor\"><\/a>Normal log messages<\/h3>\n<pre><code class=\"language-kotlin\">import clog.dsl.*\n\nv   { &quot;message&quot; }\nd   { &quot;message&quot; }\ni   { &quot;message&quot; }\nw   { &quot;message&quot; }\ne   { &quot;message&quot; }\nwtf { &quot;message&quot; }\n<\/code><\/pre>\n<h3 id=\"logs-with-custom-tags-1\"><a href=\"#logs-with-custom-tags-1\" id=\"logs-with-custom-tags-1\" class=\"anchor\"><\/a>Logs with custom tags<\/h3>\n<pre><code class=\"language-kotlin\">import clog.dsl.*\n\nv(&quot;tag&quot;)   { &quot;message&quot; }\nd(&quot;tag&quot;)   { &quot;message&quot; }\ni(&quot;tag&quot;)   { &quot;message&quot; }\nw(&quot;tag&quot;)   { &quot;message&quot; }\ne(&quot;tag&quot;)   { &quot;message&quot; }\nwtf(&quot;tag&quot;) { &quot;message&quot; }\n<\/code><\/pre>\n<h3 id=\"message-formatting-1\"><a href=\"#message-formatting-1\" id=\"message-formatting-1\" class=\"anchor\"><\/a>Message formatting<\/h3>\n<pre><code class=\"language-kotlin\">import clog.dsl.*\n\nval foo = &quot;bar&quot; \nv   { format(&quot;message {}&quot;, foo) } // logs 'message bar'\nd   { format(&quot;message {}&quot;, foo) } // logs 'message bar'\ni   { format(&quot;message {}&quot;, foo) } // logs 'message bar'\nw   { format(&quot;message {}&quot;, foo) } // logs 'message bar'\ne   { format(&quot;message {}&quot;, foo) } // logs 'message bar'\nwtf { format(&quot;message {}&quot;, foo) } // logs 'message bar'\n<\/code><\/pre>\n<h2 id=\"slf4j\"><a href=\"#slf4j\" id=\"slf4j\" class=\"anchor\"><\/a>SLF4J<\/h2>\n<p>On plain JVM and Android platforms, Clog is set up as an SLF4J binding; that is, SLF4J will pass log messages through to\nClog. Other libraries and frameworks logging to SLF4J will be formatted as normal Clog logs for uniform log output, and\nso Clog can be used as a simple SLF4J binding when you don't want to configure Logback. Additionally, SLF Mapped\nDiagnostic Context (MDC) is supported, and context data can be added to log messages with the standard format of\n<code>%X{mdcKey}<\/code>.<\/p>\n<pre><code class=\"language-kotlin\">val slf4j: Logger = LoggerFactory.getLogger(JvmClogSlf4jTest::class.java)\n\nMDC.put(&quot;akey&quot;, &quot;avalue&quot;)\nslf4j.trace(&quot;message %X{akey}&quot;) // logs 'message avalue' to the Clog logger\n<\/code><\/pre>\n<h2 id=\"more-customization\"><a href=\"#more-customization\" id=\"more-customization\" class=\"anchor\"><\/a>More Customization<\/h2>\n<p>Clog is designed to work out-of-the-box with absolutely zero config required to start logging with it. However, you can\ncustomize all components of Clog to your needs. Clog is comprised of several components wrapped in a <code>ClogProfile<\/code>,\nwhich is the global instance of <code>Clog.getInstance()<\/code>. You can customize your Clog by creating a new Profile with your\ncustom components:<\/p>\n<pre><code class=\"language-kotlin\">val newProfile = ClogProfile(...)\nClog.setProfile(newProfile)\n<\/code><\/pre>\n<p>You can also use the <code>Clog.updateProfile<\/code> helper to create a profile based on the current global instance:<\/p>\n<pre><code class=\"language-kotlin\">Clog.updateProfile { it.copy(logger = newLogger) }\n<\/code><\/pre>\n<p>The table below describes the classes that can be customized in the <code>ClogProfile<\/code>, along with their default\nimplementation for each supported platform:<\/p>\n<table class=\"table\">\n<thead>\n<tr><th>Interface<\/th><th>Description<\/th><th>JVM<\/th><th>Android<\/th><th>JS<\/th><th>iOS<\/th><\/tr>\n<\/thead>\n<tbody>\n<tr><td><code>ClogTagProvider<\/code><\/td><td>Infers a tag if one is not provided to the logging call<\/td><td><code>DefaultTagProvider()<\/code><\/td><td><code>DefaultTagProvider()<\/code><\/td><td><code>DefaultTagProvider()<\/code><\/td><td><code>DefaultTagProvider()<\/code><\/td><\/tr>\n<tr><td><code>ClogMessageFormatter<\/code><\/td><td>Formats a message string to pass to the <code>ClogLogger<\/code><\/td><td><code>Slf4jMessageFormatter(DefaultMessageFormatter())<\/code><\/td><td><code>DefaultMessageFormatter()<\/code><\/td><td><code>DefaultMessageFormatter()<\/code><\/td><td><code>DefaultMessageFormatter()<\/code><\/td><\/tr>\n<tr><td><code>ClogFilter<\/code><\/td><td>Determines whether to format and log a message<\/td><td><code>DefaultFilter()<\/code><\/td><td><code>DefaultFilter()<\/code><\/td><td><code>DefaultFilter()<\/code><\/td><td><code>DefaultFilter()<\/code><\/td><\/tr>\n<tr><td><code>ClogLogger<\/code><\/td><td>Prints a formatted log to a lower-level platform-specific logger or console<\/td><td><code>DefaultLogger()<\/code><\/td><td><code>AndroidLogger()<\/code><\/td><td><code>JsConsoleLogger()<\/code><\/td><td><code>NsLogger()<\/code><\/td><\/tr>\n<\/tbody>\n<\/table>\n<h2 id=\"recipes\"><a href=\"#recipes\" id=\"recipes\" class=\"anchor\"><\/a>Recipes<\/h2>\n<h3 id=\"turn-off-logging-in-production\"><a href=\"#turn-off-logging-in-production\" id=\"turn-off-logging-in-production\" class=\"anchor\"><\/a>Turn off logging in production<\/h3>\n<pre><code class=\"language-kotlin\">val isDebug = ...\nClog.configureLoggingInProduction(isDebug)\n<\/code><\/pre>\n<h3 id=\"use-a-custom-logger\"><a href=\"#use-a-custom-logger\" id=\"use-a-custom-logger\" class=\"anchor\"><\/a>Use a custom logger<\/h3>\n<p>Replaces the current logging target with a custom one.<\/p>\n<pre><code class=\"language-kotlin\">val customLogger = object : ClogLogger {\n    override fun log(priority: Clog.Priority, tag: String?, message: String) {\n        ...\n    }\n    override fun logException(priority: Clog.Priority, tag: String?, throwable: Throwable) {\n        ...\n    }\n}\nClog.updateProfile { it.copy(logger = customLogger) }\n<\/code><\/pre>\n<h3 id=\"using-multiple-logging-targets\"><a href=\"#using-multiple-logging-targets\" id=\"using-multiple-logging-targets\" class=\"anchor\"><\/a>Using multiple logging targets<\/h3>\n<p>Add an additional logger to the current instance. Calling <code>addLogger<\/code> multiple times will continue adding loggers, and\nmessages will be delegated to all loggers.<\/p>\n<pre><code class=\"language-kotlin\">val customLogger = object : ClogLogger {\n    override fun log(priority: Clog.Priority, tag: String?, message: String) {\n        ...\n    }\n    override fun logException(priority: Clog.Priority, tag: String?, throwable: Throwable) {\n        ...\n    }\n}\nClog.addLogger(customLogger)\n<\/code><\/pre>\n<h3 id=\"using-clog-with-dependency-injection\"><a href=\"#using-clog-with-dependency-injection\" id=\"using-clog-with-dependency-injection\" class=\"anchor\"><\/a>Using Clog with dependency injection<\/h3>\n<pre><code class=\"language-kotlin\">// Given some classes that depend on a logger\nclass Controller(val logger: ClogProfile) \n\n// just declare a ClogProfile singleton with any configurations you need \nval module = module { \n  single { ClogProfile() } \n  single { Controller(get()) } \n} \n<\/code><\/pre>\n"
        }]
      },
      "js": {
        "ownKey": "js",
        "ownPages": [{
          "reference": {
            "path": "kotlindoc",
            "baseUrl": "https://copper-leaf.github.io/clog",
            "fileName": "js",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/clog/kotlindoc/js"
          },
          "description": "",
          "title": "JS",
          "content": "<h2 id=\"clog\"><a href=\"#clog\" id=\"clog\" class=\"anchor\"><\/a>Clog<\/h2>\n<p>Zero-config Kotlin multiplatform logging utility, strongly inspired by the <a href=\"http://www.slf4j.org/\">SLF4J<\/a> and\n<a href=\"https://github.com/JakeWharton/timber\">Timber<\/a> APIs.<\/p>\n<p><img src=\"https://img.shields.io/github/v/release/copper-leaf/clog\" alt=\"GitHub release (latest by date)\" />\n<img src=\"https://img.shields.io/maven-central/v/io.github.copper-leaf/clog-core\" alt=\"Maven Central\" />\n<img src=\"https://img.shields.io/badge/Kotlin-1.4.32-orange\" alt=\"Kotlin Version\" /><\/p>\n<p>Clog is designed with the following goals in mind:<\/p>\n<ul>\n<li><strong>Zero setup required<\/strong>: just add the dependency and start logging<\/li>\n<li><strong>Support natural logging for each platform<\/strong>: use <code>actual/expect<\/code> declarations to provide natural logging targets for\neach platform, rather than printing everything to stdout<\/li>\n<li><strong>Be a central logger<\/strong>: Unlike many other Kotlin/Multiplatform loggers which simply delegate to SLF4j, Clog is designed\nto be the central logger instead of a wrapper around another logger. Clog <em>is<\/em> an SLF4J implementation, so logs from\nother libraries will be passed through to Clog and can be configured and filtered using Clog's APIs.<\/li>\n<li><strong>Support existing standards for logging<\/strong>: with the API of Timber and semantics compatible with SLF4J, Clog is a\nnatural way to transition your JVM-specific logging into the Kotlin/Multiplatform world<\/li>\n<li><strong>Customization is there if you need it<\/strong>: the Clog singleton can be easily configured with custom classes to apply\nyour own formatting, filtering, and logging targets<\/li>\n<li><strong>Immutable loggers<\/strong>: The ClogProfile and all classes implementing the logger are immutable, for multithreaded\nperformance and safety. The global Clog instance is updated only by swapping out the backing instance, and you're\nfree to bypass the global instance entirely and inject loggers instead.<\/li>\n<\/ul>\n<h3 id=\"supported-platformsfeatures\"><a href=\"#supported-platformsfeatures\" id=\"supported-platformsfeatures\" class=\"anchor\"><\/a>Supported Platforms/Features<\/h3>\n<table class=\"table\">\n<thead>\n<tr><th>Platform<\/th><th>Logging Target<\/th><th>ANSI Colors<\/th><th>Tag Inference<\/th><th>Message Formatting<\/th><th>SLF4J Integration<\/th><th>SLF4J MDC Support<\/th><\/tr>\n<\/thead>\n<tbody>\n<tr><td>JVM<\/td><td>System.out<\/td><td>✅<\/td><td>✅<\/td><td>✅<\/td><td>✅<\/td><td>✅<\/td><\/tr>\n<tr><td>Android<\/td><td>android.util.Log<\/td><td>❌<\/td><td>✅<\/td><td>✅<\/td><td>✅<\/td><td>❌<\/td><\/tr>\n<tr><td>JS<\/td><td>console.log<\/td><td>❌<\/td><td>❌<\/td><td>✅<\/td><td>❌<\/td><td>❌<\/td><\/tr>\n<tr><td>iOS<\/td><td>NSLog<\/td><td>❌<\/td><td>❌<\/td><td>✅<\/td><td>❌<\/td><td>❌<\/td><\/tr>\n<\/tbody>\n<\/table>\n<h3 id=\"installation\"><a href=\"#installation\" id=\"installation\" class=\"anchor\"><\/a>Installation<\/h3>\n<pre><code class=\"language-kotlin\">repositories {\n    mavenCentral()\n}\n\n// for plain JVM or Android projects\ndependencies {\n    implementation(&quot;io.github.copper-leaf:clog-core:4.1.1&quot;)\n}\n\n// for multiplatform projects\nkotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                implementation(&quot;io.github.copper-leaf:clog-core:4.1.1&quot;)\n            }\n        }\n    }\n}\n<\/code><\/pre>\n<h2 id=\"usage\"><a href=\"#usage\" id=\"usage\" class=\"anchor\"><\/a>Usage<\/h2>\n<p>Clog's logging levels generally follow the SLF4J logging levels, and the API follows a similar API as\n<a href=\"https://developer.android.com/reference/android/util/Log\">android.util.log<\/a> or\n<a href=\"https://github.com/JakeWharton/timber\">Timber<\/a>.<\/p>\n<table class=\"table\">\n<thead>\n<tr><th>Clog Level<\/th><th>Clog Method<\/th><th>SLF4J Level<\/th><\/tr>\n<\/thead>\n<tbody>\n<tr><td>Verbose<\/td><td><code>Clog.v()<\/code><\/td><td><code>logger.trace()<\/code><\/td><\/tr>\n<tr><td>Debug<\/td><td><code>Clog.d()<\/code><\/td><td><code>logger.debug()<\/code><\/td><\/tr>\n<tr><td>Info<\/td><td><code>Clog.i()<\/code><\/td><td><code>logger.info()<\/code><\/td><\/tr>\n<tr><td>Default<\/td><td><code>Clog.log()<\/code><\/td><td>N/A<\/td><\/tr>\n<tr><td>Warning<\/td><td><code>Clog.w()<\/code><\/td><td><code>logger.warn()<\/code><\/td><\/tr>\n<tr><td>Error<\/td><td><code>Clog.e()<\/code><\/td><td><code>logger.error()<\/code><\/td><\/tr>\n<tr><td>Fatal<\/td><td><code>Clog.wtf()<\/code><\/td><td>N/A<\/td><\/tr>\n<\/tbody>\n<\/table>\n<p>In general, a log consists of a <em>message<\/em> (which may be formatted with params in SLF4J-style), a <em>tag<\/em>, and a\n<em>log level<\/em>. Below is a description of the API<\/p>\n<h3 id=\"normal-log-messages\"><a href=\"#normal-log-messages\" id=\"normal-log-messages\" class=\"anchor\"><\/a>Normal log messages<\/h3>\n<p>Tag will be inferred on supported platforms, based on the calling class<\/p>\n<pre><code class=\"language-kotlin\">Clog.v(&quot;message&quot;)\nClog.d(&quot;message&quot;)\nClog.i(&quot;message&quot;)\nClog.log(&quot;message&quot;)\nClog.w(&quot;message&quot;)\nClog.e(&quot;message&quot;)\nClog.wtf(&quot;message&quot;)\n<\/code><\/pre>\n<h3 id=\"logs-with-custom-tags\"><a href=\"#logs-with-custom-tags\" id=\"logs-with-custom-tags\" class=\"anchor\"><\/a>Logs with custom tags<\/h3>\n<pre><code class=\"language-kotlin\">Clog.tag(&quot;tag&quot;).v(&quot;message&quot;)\nClog.tag(&quot;tag&quot;).d(&quot;message&quot;)\nClog.tag(&quot;tag&quot;).i(&quot;message&quot;)\nClog.tag(&quot;tag&quot;).w(&quot;message&quot;)\nClog.tag(&quot;tag&quot;).e(&quot;message&quot;)\nClog.tag(&quot;tag&quot;).wtf(&quot;message&quot;)\n<\/code><\/pre>\n<h3 id=\"log-exceptions\"><a href=\"#log-exceptions\" id=\"log-exceptions\" class=\"anchor\"><\/a>Log exceptions<\/h3>\n<pre><code class=\"language-kotlin\">val e = RuntimeException()\nClog.v(e)\nClog.d(e)\nClog.i(e)\nClog.log(e)\nClog.w(e)\nClog.e(e)\nClog.wtf(e)\n<\/code><\/pre>\n<h3 id=\"message-formatting\"><a href=\"#message-formatting\" id=\"message-formatting\" class=\"anchor\"><\/a>Message Formatting<\/h3>\n<p>SLF4j-style formatting is supported, replacing <code>{}<\/code> with params passed to the logging call. This is supported on all\nplatforms and all log levels.<\/p>\n<pre><code class=\"language-kotlin\">val foo = &quot;bar&quot;\nClog.i(&quot;message {}&quot;, foo) // logs 'message bar'\n<\/code><\/pre>\n<h3 id=\"priority-filter\"><a href=\"#priority-filter\" id=\"priority-filter\" class=\"anchor\"><\/a>Priority Filter<\/h3>\n<p>Messages and exceptions can be filtered out by priority.<\/p>\n<pre><code class=\"language-kotlin\">Clog.setMinPriority(Clog.Priority.ERROR)\n<\/code><\/pre>\n<h3 id=\"tag-whitelistingblacklisting\"><a href=\"#tag-whitelistingblacklisting\" id=\"tag-whitelistingblacklisting\" class=\"anchor\"><\/a>Tag whitelisting/blacklisting<\/h3>\n<p>Messages can be filtered out by tags.<\/p>\n<pre><code class=\"language-kotlin\">Clog.addTagToWhitelist(&quot;tag1&quot;)\nClog.addTagToBlacklist(&quot;tag2&quot;)\n<\/code><\/pre>\n<h2 id=\"lambda-dsl\"><a href=\"#lambda-dsl\" id=\"lambda-dsl\" class=\"anchor\"><\/a>Lambda DSL<\/h2>\n<p>Using the Clog DSL, simple strings can be logged lazily. The lambda is only evaluated if the logging level and tag is\nenabled. By default, messages logged with the lambda DSL are not formatted, but it can be re-enabled by using <code>format()<\/code>\ninside the lambda.<\/p>\n<h3 id=\"normal-log-messages-1\"><a href=\"#normal-log-messages-1\" id=\"normal-log-messages-1\" class=\"anchor\"><\/a>Normal log messages<\/h3>\n<pre><code class=\"language-kotlin\">import clog.dsl.*\n\nv   { &quot;message&quot; }\nd   { &quot;message&quot; }\ni   { &quot;message&quot; }\nw   { &quot;message&quot; }\ne   { &quot;message&quot; }\nwtf { &quot;message&quot; }\n<\/code><\/pre>\n<h3 id=\"logs-with-custom-tags-1\"><a href=\"#logs-with-custom-tags-1\" id=\"logs-with-custom-tags-1\" class=\"anchor\"><\/a>Logs with custom tags<\/h3>\n<pre><code class=\"language-kotlin\">import clog.dsl.*\n\nv(&quot;tag&quot;)   { &quot;message&quot; }\nd(&quot;tag&quot;)   { &quot;message&quot; }\ni(&quot;tag&quot;)   { &quot;message&quot; }\nw(&quot;tag&quot;)   { &quot;message&quot; }\ne(&quot;tag&quot;)   { &quot;message&quot; }\nwtf(&quot;tag&quot;) { &quot;message&quot; }\n<\/code><\/pre>\n<h3 id=\"message-formatting-1\"><a href=\"#message-formatting-1\" id=\"message-formatting-1\" class=\"anchor\"><\/a>Message formatting<\/h3>\n<pre><code class=\"language-kotlin\">import clog.dsl.*\n\nval foo = &quot;bar&quot; \nv   { format(&quot;message {}&quot;, foo) } // logs 'message bar'\nd   { format(&quot;message {}&quot;, foo) } // logs 'message bar'\ni   { format(&quot;message {}&quot;, foo) } // logs 'message bar'\nw   { format(&quot;message {}&quot;, foo) } // logs 'message bar'\ne   { format(&quot;message {}&quot;, foo) } // logs 'message bar'\nwtf { format(&quot;message {}&quot;, foo) } // logs 'message bar'\n<\/code><\/pre>\n<h2 id=\"slf4j\"><a href=\"#slf4j\" id=\"slf4j\" class=\"anchor\"><\/a>SLF4J<\/h2>\n<p>On plain JVM and Android platforms, Clog is set up as an SLF4J binding; that is, SLF4J will pass log messages through to\nClog. Other libraries and frameworks logging to SLF4J will be formatted as normal Clog logs for uniform log output, and\nso Clog can be used as a simple SLF4J binding when you don't want to configure Logback. Additionally, SLF Mapped\nDiagnostic Context (MDC) is supported, and context data can be added to log messages with the standard format of\n<code>%X{mdcKey}<\/code>.<\/p>\n<pre><code class=\"language-kotlin\">val slf4j: Logger = LoggerFactory.getLogger(JvmClogSlf4jTest::class.java)\n\nMDC.put(&quot;akey&quot;, &quot;avalue&quot;)\nslf4j.trace(&quot;message %X{akey}&quot;) // logs 'message avalue' to the Clog logger\n<\/code><\/pre>\n<h2 id=\"more-customization\"><a href=\"#more-customization\" id=\"more-customization\" class=\"anchor\"><\/a>More Customization<\/h2>\n<p>Clog is designed to work out-of-the-box with absolutely zero config required to start logging with it. However, you can\ncustomize all components of Clog to your needs. Clog is comprised of several components wrapped in a <code>ClogProfile<\/code>,\nwhich is the global instance of <code>Clog.getInstance()<\/code>. You can customize your Clog by creating a new Profile with your\ncustom components:<\/p>\n<pre><code class=\"language-kotlin\">val newProfile = ClogProfile(...)\nClog.setProfile(newProfile)\n<\/code><\/pre>\n<p>You can also use the <code>Clog.updateProfile<\/code> helper to create a profile based on the current global instance:<\/p>\n<pre><code class=\"language-kotlin\">Clog.updateProfile { it.copy(logger = newLogger) }\n<\/code><\/pre>\n<p>The table below describes the classes that can be customized in the <code>ClogProfile<\/code>, along with their default\nimplementation for each supported platform:<\/p>\n<table class=\"table\">\n<thead>\n<tr><th>Interface<\/th><th>Description<\/th><th>JVM<\/th><th>Android<\/th><th>JS<\/th><th>iOS<\/th><\/tr>\n<\/thead>\n<tbody>\n<tr><td><code>ClogTagProvider<\/code><\/td><td>Infers a tag if one is not provided to the logging call<\/td><td><code>DefaultTagProvider()<\/code><\/td><td><code>DefaultTagProvider()<\/code><\/td><td><code>DefaultTagProvider()<\/code><\/td><td><code>DefaultTagProvider()<\/code><\/td><\/tr>\n<tr><td><code>ClogMessageFormatter<\/code><\/td><td>Formats a message string to pass to the <code>ClogLogger<\/code><\/td><td><code>Slf4jMessageFormatter(DefaultMessageFormatter())<\/code><\/td><td><code>DefaultMessageFormatter()<\/code><\/td><td><code>DefaultMessageFormatter()<\/code><\/td><td><code>DefaultMessageFormatter()<\/code><\/td><\/tr>\n<tr><td><code>ClogFilter<\/code><\/td><td>Determines whether to format and log a message<\/td><td><code>DefaultFilter()<\/code><\/td><td><code>DefaultFilter()<\/code><\/td><td><code>DefaultFilter()<\/code><\/td><td><code>DefaultFilter()<\/code><\/td><\/tr>\n<tr><td><code>ClogLogger<\/code><\/td><td>Prints a formatted log to a lower-level platform-specific logger or console<\/td><td><code>DefaultLogger()<\/code><\/td><td><code>AndroidLogger()<\/code><\/td><td><code>JsConsoleLogger()<\/code><\/td><td><code>NsLogger()<\/code><\/td><\/tr>\n<\/tbody>\n<\/table>\n<h2 id=\"recipes\"><a href=\"#recipes\" id=\"recipes\" class=\"anchor\"><\/a>Recipes<\/h2>\n<h3 id=\"turn-off-logging-in-production\"><a href=\"#turn-off-logging-in-production\" id=\"turn-off-logging-in-production\" class=\"anchor\"><\/a>Turn off logging in production<\/h3>\n<pre><code class=\"language-kotlin\">val isDebug = ...\nClog.configureLoggingInProduction(isDebug)\n<\/code><\/pre>\n<h3 id=\"use-a-custom-logger\"><a href=\"#use-a-custom-logger\" id=\"use-a-custom-logger\" class=\"anchor\"><\/a>Use a custom logger<\/h3>\n<p>Replaces the current logging target with a custom one.<\/p>\n<pre><code class=\"language-kotlin\">val customLogger = object : ClogLogger {\n    override fun log(priority: Clog.Priority, tag: String?, message: String) {\n        ...\n    }\n    override fun logException(priority: Clog.Priority, tag: String?, throwable: Throwable) {\n        ...\n    }\n}\nClog.updateProfile { it.copy(logger = customLogger) }\n<\/code><\/pre>\n<h3 id=\"using-multiple-logging-targets\"><a href=\"#using-multiple-logging-targets\" id=\"using-multiple-logging-targets\" class=\"anchor\"><\/a>Using multiple logging targets<\/h3>\n<p>Add an additional logger to the current instance. Calling <code>addLogger<\/code> multiple times will continue adding loggers, and\nmessages will be delegated to all loggers.<\/p>\n<pre><code class=\"language-kotlin\">val customLogger = object : ClogLogger {\n    override fun log(priority: Clog.Priority, tag: String?, message: String) {\n        ...\n    }\n    override fun logException(priority: Clog.Priority, tag: String?, throwable: Throwable) {\n        ...\n    }\n}\nClog.addLogger(customLogger)\n<\/code><\/pre>\n<h3 id=\"using-clog-with-dependency-injection\"><a href=\"#using-clog-with-dependency-injection\" id=\"using-clog-with-dependency-injection\" class=\"anchor\"><\/a>Using Clog with dependency injection<\/h3>\n<pre><code class=\"language-kotlin\">// Given some classes that depend on a logger\nclass Controller(val logger: ClogProfile) \n\n// just declare a ClogProfile singleton with any configurations you need \nval module = module { \n  single { ClogProfile() } \n  single { Controller(get()) } \n} \n<\/code><\/pre>\n"
        }]
      },
      "ios": {
        "ownKey": "ios",
        "ownPages": [{
          "reference": {
            "path": "kotlindoc",
            "baseUrl": "https://copper-leaf.github.io/clog",
            "fileName": "ios",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/clog/kotlindoc/ios"
          },
          "description": "",
          "title": "iOS",
          "content": "<h2 id=\"clog\"><a href=\"#clog\" id=\"clog\" class=\"anchor\"><\/a>Clog<\/h2>\n<p>Zero-config Kotlin multiplatform logging utility, strongly inspired by the <a href=\"http://www.slf4j.org/\">SLF4J<\/a> and\n<a href=\"https://github.com/JakeWharton/timber\">Timber<\/a> APIs.<\/p>\n<p><img src=\"https://img.shields.io/github/v/release/copper-leaf/clog\" alt=\"GitHub release (latest by date)\" />\n<img src=\"https://img.shields.io/maven-central/v/io.github.copper-leaf/clog-core\" alt=\"Maven Central\" />\n<img src=\"https://img.shields.io/badge/Kotlin-1.4.32-orange\" alt=\"Kotlin Version\" /><\/p>\n<p>Clog is designed with the following goals in mind:<\/p>\n<ul>\n<li><strong>Zero setup required<\/strong>: just add the dependency and start logging<\/li>\n<li><strong>Support natural logging for each platform<\/strong>: use <code>actual/expect<\/code> declarations to provide natural logging targets for\neach platform, rather than printing everything to stdout<\/li>\n<li><strong>Be a central logger<\/strong>: Unlike many other Kotlin/Multiplatform loggers which simply delegate to SLF4j, Clog is designed\nto be the central logger instead of a wrapper around another logger. Clog <em>is<\/em> an SLF4J implementation, so logs from\nother libraries will be passed through to Clog and can be configured and filtered using Clog's APIs.<\/li>\n<li><strong>Support existing standards for logging<\/strong>: with the API of Timber and semantics compatible with SLF4J, Clog is a\nnatural way to transition your JVM-specific logging into the Kotlin/Multiplatform world<\/li>\n<li><strong>Customization is there if you need it<\/strong>: the Clog singleton can be easily configured with custom classes to apply\nyour own formatting, filtering, and logging targets<\/li>\n<li><strong>Immutable loggers<\/strong>: The ClogProfile and all classes implementing the logger are immutable, for multithreaded\nperformance and safety. The global Clog instance is updated only by swapping out the backing instance, and you're\nfree to bypass the global instance entirely and inject loggers instead.<\/li>\n<\/ul>\n<h3 id=\"supported-platformsfeatures\"><a href=\"#supported-platformsfeatures\" id=\"supported-platformsfeatures\" class=\"anchor\"><\/a>Supported Platforms/Features<\/h3>\n<table class=\"table\">\n<thead>\n<tr><th>Platform<\/th><th>Logging Target<\/th><th>ANSI Colors<\/th><th>Tag Inference<\/th><th>Message Formatting<\/th><th>SLF4J Integration<\/th><th>SLF4J MDC Support<\/th><\/tr>\n<\/thead>\n<tbody>\n<tr><td>JVM<\/td><td>System.out<\/td><td>✅<\/td><td>✅<\/td><td>✅<\/td><td>✅<\/td><td>✅<\/td><\/tr>\n<tr><td>Android<\/td><td>android.util.Log<\/td><td>❌<\/td><td>✅<\/td><td>✅<\/td><td>✅<\/td><td>❌<\/td><\/tr>\n<tr><td>JS<\/td><td>console.log<\/td><td>❌<\/td><td>❌<\/td><td>✅<\/td><td>❌<\/td><td>❌<\/td><\/tr>\n<tr><td>iOS<\/td><td>NSLog<\/td><td>❌<\/td><td>❌<\/td><td>✅<\/td><td>❌<\/td><td>❌<\/td><\/tr>\n<\/tbody>\n<\/table>\n<h3 id=\"installation\"><a href=\"#installation\" id=\"installation\" class=\"anchor\"><\/a>Installation<\/h3>\n<pre><code class=\"language-kotlin\">repositories {\n    mavenCentral()\n}\n\n// for plain JVM or Android projects\ndependencies {\n    implementation(&quot;io.github.copper-leaf:clog-core:4.1.1&quot;)\n}\n\n// for multiplatform projects\nkotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                implementation(&quot;io.github.copper-leaf:clog-core:4.1.1&quot;)\n            }\n        }\n    }\n}\n<\/code><\/pre>\n<h2 id=\"usage\"><a href=\"#usage\" id=\"usage\" class=\"anchor\"><\/a>Usage<\/h2>\n<p>Clog's logging levels generally follow the SLF4J logging levels, and the API follows a similar API as\n<a href=\"https://developer.android.com/reference/android/util/Log\">android.util.log<\/a> or\n<a href=\"https://github.com/JakeWharton/timber\">Timber<\/a>.<\/p>\n<table class=\"table\">\n<thead>\n<tr><th>Clog Level<\/th><th>Clog Method<\/th><th>SLF4J Level<\/th><\/tr>\n<\/thead>\n<tbody>\n<tr><td>Verbose<\/td><td><code>Clog.v()<\/code><\/td><td><code>logger.trace()<\/code><\/td><\/tr>\n<tr><td>Debug<\/td><td><code>Clog.d()<\/code><\/td><td><code>logger.debug()<\/code><\/td><\/tr>\n<tr><td>Info<\/td><td><code>Clog.i()<\/code><\/td><td><code>logger.info()<\/code><\/td><\/tr>\n<tr><td>Default<\/td><td><code>Clog.log()<\/code><\/td><td>N/A<\/td><\/tr>\n<tr><td>Warning<\/td><td><code>Clog.w()<\/code><\/td><td><code>logger.warn()<\/code><\/td><\/tr>\n<tr><td>Error<\/td><td><code>Clog.e()<\/code><\/td><td><code>logger.error()<\/code><\/td><\/tr>\n<tr><td>Fatal<\/td><td><code>Clog.wtf()<\/code><\/td><td>N/A<\/td><\/tr>\n<\/tbody>\n<\/table>\n<p>In general, a log consists of a <em>message<\/em> (which may be formatted with params in SLF4J-style), a <em>tag<\/em>, and a\n<em>log level<\/em>. Below is a description of the API<\/p>\n<h3 id=\"normal-log-messages\"><a href=\"#normal-log-messages\" id=\"normal-log-messages\" class=\"anchor\"><\/a>Normal log messages<\/h3>\n<p>Tag will be inferred on supported platforms, based on the calling class<\/p>\n<pre><code class=\"language-kotlin\">Clog.v(&quot;message&quot;)\nClog.d(&quot;message&quot;)\nClog.i(&quot;message&quot;)\nClog.log(&quot;message&quot;)\nClog.w(&quot;message&quot;)\nClog.e(&quot;message&quot;)\nClog.wtf(&quot;message&quot;)\n<\/code><\/pre>\n<h3 id=\"logs-with-custom-tags\"><a href=\"#logs-with-custom-tags\" id=\"logs-with-custom-tags\" class=\"anchor\"><\/a>Logs with custom tags<\/h3>\n<pre><code class=\"language-kotlin\">Clog.tag(&quot;tag&quot;).v(&quot;message&quot;)\nClog.tag(&quot;tag&quot;).d(&quot;message&quot;)\nClog.tag(&quot;tag&quot;).i(&quot;message&quot;)\nClog.tag(&quot;tag&quot;).w(&quot;message&quot;)\nClog.tag(&quot;tag&quot;).e(&quot;message&quot;)\nClog.tag(&quot;tag&quot;).wtf(&quot;message&quot;)\n<\/code><\/pre>\n<h3 id=\"log-exceptions\"><a href=\"#log-exceptions\" id=\"log-exceptions\" class=\"anchor\"><\/a>Log exceptions<\/h3>\n<pre><code class=\"language-kotlin\">val e = RuntimeException()\nClog.v(e)\nClog.d(e)\nClog.i(e)\nClog.log(e)\nClog.w(e)\nClog.e(e)\nClog.wtf(e)\n<\/code><\/pre>\n<h3 id=\"message-formatting\"><a href=\"#message-formatting\" id=\"message-formatting\" class=\"anchor\"><\/a>Message Formatting<\/h3>\n<p>SLF4j-style formatting is supported, replacing <code>{}<\/code> with params passed to the logging call. This is supported on all\nplatforms and all log levels.<\/p>\n<pre><code class=\"language-kotlin\">val foo = &quot;bar&quot;\nClog.i(&quot;message {}&quot;, foo) // logs 'message bar'\n<\/code><\/pre>\n<h3 id=\"priority-filter\"><a href=\"#priority-filter\" id=\"priority-filter\" class=\"anchor\"><\/a>Priority Filter<\/h3>\n<p>Messages and exceptions can be filtered out by priority.<\/p>\n<pre><code class=\"language-kotlin\">Clog.setMinPriority(Clog.Priority.ERROR)\n<\/code><\/pre>\n<h3 id=\"tag-whitelistingblacklisting\"><a href=\"#tag-whitelistingblacklisting\" id=\"tag-whitelistingblacklisting\" class=\"anchor\"><\/a>Tag whitelisting/blacklisting<\/h3>\n<p>Messages can be filtered out by tags.<\/p>\n<pre><code class=\"language-kotlin\">Clog.addTagToWhitelist(&quot;tag1&quot;)\nClog.addTagToBlacklist(&quot;tag2&quot;)\n<\/code><\/pre>\n<h2 id=\"lambda-dsl\"><a href=\"#lambda-dsl\" id=\"lambda-dsl\" class=\"anchor\"><\/a>Lambda DSL<\/h2>\n<p>Using the Clog DSL, simple strings can be logged lazily. The lambda is only evaluated if the logging level and tag is\nenabled. By default, messages logged with the lambda DSL are not formatted, but it can be re-enabled by using <code>format()<\/code>\ninside the lambda.<\/p>\n<h3 id=\"normal-log-messages-1\"><a href=\"#normal-log-messages-1\" id=\"normal-log-messages-1\" class=\"anchor\"><\/a>Normal log messages<\/h3>\n<pre><code class=\"language-kotlin\">import clog.dsl.*\n\nv   { &quot;message&quot; }\nd   { &quot;message&quot; }\ni   { &quot;message&quot; }\nw   { &quot;message&quot; }\ne   { &quot;message&quot; }\nwtf { &quot;message&quot; }\n<\/code><\/pre>\n<h3 id=\"logs-with-custom-tags-1\"><a href=\"#logs-with-custom-tags-1\" id=\"logs-with-custom-tags-1\" class=\"anchor\"><\/a>Logs with custom tags<\/h3>\n<pre><code class=\"language-kotlin\">import clog.dsl.*\n\nv(&quot;tag&quot;)   { &quot;message&quot; }\nd(&quot;tag&quot;)   { &quot;message&quot; }\ni(&quot;tag&quot;)   { &quot;message&quot; }\nw(&quot;tag&quot;)   { &quot;message&quot; }\ne(&quot;tag&quot;)   { &quot;message&quot; }\nwtf(&quot;tag&quot;) { &quot;message&quot; }\n<\/code><\/pre>\n<h3 id=\"message-formatting-1\"><a href=\"#message-formatting-1\" id=\"message-formatting-1\" class=\"anchor\"><\/a>Message formatting<\/h3>\n<pre><code class=\"language-kotlin\">import clog.dsl.*\n\nval foo = &quot;bar&quot; \nv   { format(&quot;message {}&quot;, foo) } // logs 'message bar'\nd   { format(&quot;message {}&quot;, foo) } // logs 'message bar'\ni   { format(&quot;message {}&quot;, foo) } // logs 'message bar'\nw   { format(&quot;message {}&quot;, foo) } // logs 'message bar'\ne   { format(&quot;message {}&quot;, foo) } // logs 'message bar'\nwtf { format(&quot;message {}&quot;, foo) } // logs 'message bar'\n<\/code><\/pre>\n<h2 id=\"slf4j\"><a href=\"#slf4j\" id=\"slf4j\" class=\"anchor\"><\/a>SLF4J<\/h2>\n<p>On plain JVM and Android platforms, Clog is set up as an SLF4J binding; that is, SLF4J will pass log messages through to\nClog. Other libraries and frameworks logging to SLF4J will be formatted as normal Clog logs for uniform log output, and\nso Clog can be used as a simple SLF4J binding when you don't want to configure Logback. Additionally, SLF Mapped\nDiagnostic Context (MDC) is supported, and context data can be added to log messages with the standard format of\n<code>%X{mdcKey}<\/code>.<\/p>\n<pre><code class=\"language-kotlin\">val slf4j: Logger = LoggerFactory.getLogger(JvmClogSlf4jTest::class.java)\n\nMDC.put(&quot;akey&quot;, &quot;avalue&quot;)\nslf4j.trace(&quot;message %X{akey}&quot;) // logs 'message avalue' to the Clog logger\n<\/code><\/pre>\n<h2 id=\"more-customization\"><a href=\"#more-customization\" id=\"more-customization\" class=\"anchor\"><\/a>More Customization<\/h2>\n<p>Clog is designed to work out-of-the-box with absolutely zero config required to start logging with it. However, you can\ncustomize all components of Clog to your needs. Clog is comprised of several components wrapped in a <code>ClogProfile<\/code>,\nwhich is the global instance of <code>Clog.getInstance()<\/code>. You can customize your Clog by creating a new Profile with your\ncustom components:<\/p>\n<pre><code class=\"language-kotlin\">val newProfile = ClogProfile(...)\nClog.setProfile(newProfile)\n<\/code><\/pre>\n<p>You can also use the <code>Clog.updateProfile<\/code> helper to create a profile based on the current global instance:<\/p>\n<pre><code class=\"language-kotlin\">Clog.updateProfile { it.copy(logger = newLogger) }\n<\/code><\/pre>\n<p>The table below describes the classes that can be customized in the <code>ClogProfile<\/code>, along with their default\nimplementation for each supported platform:<\/p>\n<table class=\"table\">\n<thead>\n<tr><th>Interface<\/th><th>Description<\/th><th>JVM<\/th><th>Android<\/th><th>JS<\/th><th>iOS<\/th><\/tr>\n<\/thead>\n<tbody>\n<tr><td><code>ClogTagProvider<\/code><\/td><td>Infers a tag if one is not provided to the logging call<\/td><td><code>DefaultTagProvider()<\/code><\/td><td><code>DefaultTagProvider()<\/code><\/td><td><code>DefaultTagProvider()<\/code><\/td><td><code>DefaultTagProvider()<\/code><\/td><\/tr>\n<tr><td><code>ClogMessageFormatter<\/code><\/td><td>Formats a message string to pass to the <code>ClogLogger<\/code><\/td><td><code>Slf4jMessageFormatter(DefaultMessageFormatter())<\/code><\/td><td><code>DefaultMessageFormatter()<\/code><\/td><td><code>DefaultMessageFormatter()<\/code><\/td><td><code>DefaultMessageFormatter()<\/code><\/td><\/tr>\n<tr><td><code>ClogFilter<\/code><\/td><td>Determines whether to format and log a message<\/td><td><code>DefaultFilter()<\/code><\/td><td><code>DefaultFilter()<\/code><\/td><td><code>DefaultFilter()<\/code><\/td><td><code>DefaultFilter()<\/code><\/td><\/tr>\n<tr><td><code>ClogLogger<\/code><\/td><td>Prints a formatted log to a lower-level platform-specific logger or console<\/td><td><code>DefaultLogger()<\/code><\/td><td><code>AndroidLogger()<\/code><\/td><td><code>JsConsoleLogger()<\/code><\/td><td><code>NsLogger()<\/code><\/td><\/tr>\n<\/tbody>\n<\/table>\n<h2 id=\"recipes\"><a href=\"#recipes\" id=\"recipes\" class=\"anchor\"><\/a>Recipes<\/h2>\n<h3 id=\"turn-off-logging-in-production\"><a href=\"#turn-off-logging-in-production\" id=\"turn-off-logging-in-production\" class=\"anchor\"><\/a>Turn off logging in production<\/h3>\n<pre><code class=\"language-kotlin\">val isDebug = ...\nClog.configureLoggingInProduction(isDebug)\n<\/code><\/pre>\n<h3 id=\"use-a-custom-logger\"><a href=\"#use-a-custom-logger\" id=\"use-a-custom-logger\" class=\"anchor\"><\/a>Use a custom logger<\/h3>\n<p>Replaces the current logging target with a custom one.<\/p>\n<pre><code class=\"language-kotlin\">val customLogger = object : ClogLogger {\n    override fun log(priority: Clog.Priority, tag: String?, message: String) {\n        ...\n    }\n    override fun logException(priority: Clog.Priority, tag: String?, throwable: Throwable) {\n        ...\n    }\n}\nClog.updateProfile { it.copy(logger = customLogger) }\n<\/code><\/pre>\n<h3 id=\"using-multiple-logging-targets\"><a href=\"#using-multiple-logging-targets\" id=\"using-multiple-logging-targets\" class=\"anchor\"><\/a>Using multiple logging targets<\/h3>\n<p>Add an additional logger to the current instance. Calling <code>addLogger<\/code> multiple times will continue adding loggers, and\nmessages will be delegated to all loggers.<\/p>\n<pre><code class=\"language-kotlin\">val customLogger = object : ClogLogger {\n    override fun log(priority: Clog.Priority, tag: String?, message: String) {\n        ...\n    }\n    override fun logException(priority: Clog.Priority, tag: String?, throwable: Throwable) {\n        ...\n    }\n}\nClog.addLogger(customLogger)\n<\/code><\/pre>\n<h3 id=\"using-clog-with-dependency-injection\"><a href=\"#using-clog-with-dependency-injection\" id=\"using-clog-with-dependency-injection\" class=\"anchor\"><\/a>Using Clog with dependency injection<\/h3>\n<pre><code class=\"language-kotlin\">// Given some classes that depend on a logger\nclass Controller(val logger: ClogProfile) \n\n// just declare a ClogProfile singleton with any configurations you need \nval module = module { \n  single { ClogProfile() } \n  single { Controller(get()) } \n} \n<\/code><\/pre>\n"
        }]
      }
    }
  }}
}